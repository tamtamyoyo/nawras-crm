import { test, expect, Page } from '@playwright/test'

// Comprehensive Security Vulnerability Assessment
// Tests for XSS, CSRF, Authentication, Input Validation, and other security issues

test.describe('Security Vulnerability Assessment', () => {
  let page: Page

  test.beforeEach(async ({ page: testPage }) => {
    page = testPage
    await page.goto('http://localhost:5173')
  })

  test.describe('Cross-Site Scripting (XSS) Testing', () => {
    test('should prevent stored XSS in customer name field', async () => {
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        'javascript:alert("XSS")',
        '<svg onload=alert("XSS")>',
        '"><script>alert("XSS")</script>',
        "'><script>alert('XSS')</script>",
        '<iframe src="javascript:alert(\'XSS\')">'  
      ]

      await page.click('[data-testid="nav-customers"], a[href="/customers"], a:has-text("Customers")')
      
      // Try to create customer with XSS payload
      const createButton = await findFirstAvailableElement([
        'button:has-text("Create Customer")',
        'button:has-text("Add Customer")',
        '[data-testid="create-customer"]'
      ])
      
      if (createButton) {
        for (const payload of xssPayloads) {
          await createButton.click()
          
          await fillFirstAvailableField([
            '[data-testid="customer-name"]', 
            'input[name="name"]'
          ], payload)
          
          await fillFirstAvailableField([
            '[data-testid="customer-email"]', 
            'input[name="email"]'
          ], 'xss.test@example.com')
          
          await clickFirstAvailableButton([
            'button:has-text("Save")',
            'button:has-text("Create")',
            'button[type="submit"]'
          ])
          
          await page.waitForTimeout(1000)
          
          // Check if XSS payload was executed (should not be)
          const alertDialogPresent = await page.locator('text="XSS"').count() > 0
          expect(alertDialogPresent).toBe(false)
          
          // Check if payload appears as plain text (properly escaped)
          const payloadAsText = await page.locator(`text=${payload}`).count() > 0
          if (payloadAsText) {
            // This is good - it means the payload was escaped
            console.log(`XSS payload properly escaped: ${payload}`)
          }
          
          // Close any modal that might be open
          await closeModal()
        }
      }
    })

    test('should prevent reflected XSS in search functionality', async () => {
      const xssPayloads = [
        '<script>alert("Reflected XSS")</script>',
        '<img src=x onerror=alert("Reflected XSS")>',
        '"><script>alert("Reflected XSS")</script>'
      ]

      const searchSelectors = [
        '[data-testid="search"]',
        '[data-testid="global-search"]',
        'input[placeholder*="search" i]',
        'input[type="search"]'
      ]
      
      const searchInput = await findFirstAvailableElement(searchSelectors)
      if (searchInput) {
        for (const payload of xssPayloads) {
          await searchInput.fill(payload)
          await searchInput.press('Enter')
          
          await page.waitForTimeout(1000)
          
          // Check if XSS payload was executed (should not be)
          const alertDialogPresent = await page.locator('text="Reflected XSS"').count() > 0
          expect(alertDialogPresent).toBe(false)
        }
      }
    })
  })

  test.describe('Authentication Security Testing', () => {
    test('should redirect unauthenticated users to login', async () => {
      // Clear any existing authentication
      await page.evaluate(() => {
        localStorage.clear()
        sessionStorage.clear()
      })
      
      const protectedRoutes = ['/customers', '/leads', '/deals', '/analytics']
      
      for (const route of protectedRoutes) {
        await page.goto(`http://localhost:5173${route}`)
        
        // Should redirect to login or show login form
        const isOnLogin = page.url().includes('/login') || 
                         await page.locator('[data-testid="login-page"], [data-testid="login-form"], form[action*="login"]').count() > 0
        
        expect(isOnLogin).toBe(true)
      }
    })

    test('should validate session tokens', async () => {
      // Set invalid token
      await page.evaluate(() => {
        localStorage.setItem('auth-token', 'invalid-token-12345')
      })
      
      await page.goto('http://localhost:5173/customers')
      
      // Should either redirect to login or show error
      const hasAuthError = page.url().includes('/login') || 
                          await page.locator('.error, [role="alert"], .unauthorized').count() > 0
      
      expect(hasAuthError).toBe(true)
    })

    test('should prevent session fixation', async () => {
      // Get initial session
      await page.goto('http://localhost:5173')
      const initialToken = await page.evaluate(() => localStorage.getItem('auth-token'))
      
      // Simulate login
      await page.evaluate(() => {
        localStorage.setItem('auth-token', 'valid-session-token')
      })
      
      await page.goto('http://localhost:5173/customers')
      
      // After login, token should be different (if properly implemented)
      const postLoginToken = await page.evaluate(() => localStorage.getItem('auth-token'))
      
      // This test assumes proper session management
      if (initialToken && postLoginToken) {
        expect(postLoginToken).not.toBe(initialToken)
      }
    })
  })

  test.describe('Input Validation Security Testing', () => {
    test('should validate email format', async () => {
      const invalidEmails = [
        'invalid-email',
        '@domain.com',
        'user@',
        'user..double.dot@domain.com',
        'user@domain',
        '<script>alert("xss")</script>@domain.com'
      ]

      await page.click('[data-testid="nav-customers"], a[href="/customers"], a:has-text("Customers")')
      
      const createButton = await findFirstAvailableElement([
        'button:has-text("Create Customer")',
        'button:has-text("Add Customer")',
        '[data-testid="create-customer"]'
      ])
      
      if (createButton) {
        for (const email of invalidEmails) {
          await createButton.click()
          
          await fillFirstAvailableField([
            '[data-testid="customer-name"]', 
            'input[name="name"]'
          ], 'Test User')
          
          await fillFirstAvailableField([
            '[data-testid="customer-email"]', 
            'input[name="email"]'
          ], email)
          
          await clickFirstAvailableButton([
            'button:has-text("Save")',
            'button:has-text("Create")',
            'button[type="submit"]'
          ])
          
          await page.waitForTimeout(500)
          
          // Should show validation error
          const hasValidationError = await page.locator('.error, .invalid, [role="alert"], .text-red-500').count() > 0
          expect(hasValidationError).toBe(true)
          
          await closeModal()
        }
      }
    })

    test('should prevent SQL injection in search', async () => {
      const sqlInjectionPayloads = [
        "'; DROP TABLE customers; --",
        "' OR '1'='1",
        "' UNION SELECT * FROM users --",
        "'; INSERT INTO customers VALUES ('hacker', 'hack@evil.com'); --",
        "' OR 1=1 --"
      ]

      const searchSelectors = [
        '[data-testid="search"]',
        '[data-testid="global-search"]',
        'input[placeholder*="search" i]',
        'input[type="search"]'
      ]
      
      const searchInput = await findFirstAvailableElement(searchSelectors)
      if (searchInput) {
        for (const payload of sqlInjectionPayloads) {
          await searchInput.fill(payload)
          await searchInput.press('Enter')
          
          await page.waitForTimeout(1000)
          
          // Should not cause database errors or return unexpected results
          const hasDbError = await page.locator('text=/database error/i, text=/sql error/i, text=/syntax error/i').count() > 0
          expect(hasDbError).toBe(false)
        }
      }
    })

    test('should limit input length to prevent buffer overflow', async () => {
      const longString = 'A'.repeat(10000) // Very long string
      
      await page.click('[data-testid="nav-customers"], a[href="/customers"], a:has-text("Customers")')
      
      const createButton = await findFirstAvailableElement([
        'button:has-text("Create Customer")',
        'button:has-text("Add Customer")',
        '[data-testid="create-customer"]'
      ])
      
      if (createButton) {
        await createButton.click()
        
        const nameField = await findFirstAvailableElement([
          '[data-testid="customer-name"]', 
          'input[name="name"]'
        ])
        
        if (nameField) {
          await nameField.fill(longString)
          
          const actualValue = await nameField.inputValue()
          
          // Should be truncated or limited
          expect(actualValue.length).toBeLessThan(10000)
        }
        
        await closeModal()
      }
    })
  })

  test.describe('CSRF Protection Testing', () => {
    test('should require proper CSRF tokens for state-changing operations', async () => {
      // Mock authentication
      await page.evaluate(() => {
        localStorage.setItem('auth-token', 'valid-token')
      })
      
      await page.goto('http://localhost:5173/customers')
      
      // Intercept requests to check for CSRF tokens
      let hasCSRFProtection = false
      
      page.on('request', request => {
        if (request.method() === 'POST' || request.method() === 'PUT' || request.method() === 'DELETE') {
          const headers = request.headers()
          const hasCSRFHeader = headers['x-csrf-token'] || headers['x-xsrf-token'] || headers['csrf-token']
          const hasCSRFInBody = request.postData()?.includes('csrf') || false
          
          if (hasCSRFHeader || hasCSRFInBody) {
            hasCSRFProtection = true
          }
        }
      })
      
      // Try to create a customer (should trigger POST request)
      const createButton = await findFirstAvailableElement([
        'button:has-text("Create Customer")',
        'button:has-text("Add Customer")',
        '[data-testid="create-customer"]'
      ])
      
      if (createButton) {
        await createButton.click()
        
        await fillFirstAvailableField([
          '[data-testid="customer-name"]', 
          'input[name="name"]'
        ], 'CSRF Test Customer')
        
        await fillFirstAvailableField([
          '[data-testid="customer-email"]', 
          'input[name="email"]'
        ], 'csrf.test@example.com')
        
        await clickFirstAvailableButton([
          'button:has-text("Save")',
          'button:has-text("Create")',
          'button[type="submit"]'
        ])
        
        await page.waitForTimeout(2000)
        
        // Note: This test checks if CSRF protection exists
        // In a real application, you'd want hasCSRFProtection to be true
        console.log('CSRF Protection detected:', hasCSRFProtection)
      }
    })
  })

  test.describe('Content Security Policy Testing', () => {
    test('should have proper CSP headers', async () => {
      const response = await page.goto('http://localhost:5173')
      const headers = response?.headers() || {}
      
      const cspHeader = headers['content-security-policy'] || headers['x-content-security-policy']
      
      if (cspHeader) {
        // Check for basic CSP directives
        expect(cspHeader).toContain('default-src')
        expect(cspHeader).toContain('script-src')
        expect(cspHeader).toContain('style-src')
        
        // Should not allow unsafe-inline for scripts
        expect(cspHeader).not.toContain("script-src 'unsafe-inline'")
      } else {
        console.warn('No Content Security Policy header found')
      }
    })
  })

  test.describe('Information Disclosure Testing', () => {
    test('should not expose sensitive information in client-side code', async () => {
      // Check for common sensitive information patterns
      const pageContent = await page.content()
      
      const sensitivePatterns = [
        /password\s*[:=]\s*['"][^'"]+['"]/i,
        /api[_-]?key\s*[:=]\s*['"][^'"]+['"]/i,
        /secret\s*[:=]\s*['"][^'"]+['"]/i,
        /token\s*[:=]\s*['"][a-zA-Z0-9]{20,}['"]/i,
        /database\s*[:=]\s*['"][^'"]+['"]/i
      ]
      
      for (const pattern of sensitivePatterns) {
        const matches = pageContent.match(pattern)
        if (matches) {
          console.warn('Potential sensitive information found:', matches[0])
        }
        expect(matches).toBeNull()
      }
    })

    test('should not expose stack traces in production', async () => {
      // Try to trigger an error
      await page.goto('http://localhost:5173/nonexistent-page')
      
      const pageContent = await page.content()
      
      // Should not contain stack traces
      const hasStackTrace = /at\s+\w+\s+\([^)]+:\d+:\d+\)/i.test(pageContent) ||
                           /Error:\s+[\w\s]+\n\s+at\s+/i.test(pageContent)
      
      expect(hasStackTrace).toBe(false)
    })
  })

  // Helper functions
  async function fillFirstAvailableField(selectors: string[], value: string) {
    for (const selector of selectors) {
      const field = page.locator(selector)
      if (await field.count() > 0 && await field.isVisible()) {
        await field.fill(value)
        return
      }
    }
  }

  async function clickFirstAvailableButton(selectors: string[]) {
    for (const selector of selectors) {
      const button = page.locator(selector)
      if (await button.count() > 0 && await button.isVisible()) {
        await button.click()
        return
      }
    }
  }

  async function findFirstAvailableElement(selectors: string[]) {
    for (const selector of selectors) {
      const element = page.locator(selector)
      if (await element.count() > 0 && await element.isVisible()) {
        return element
      }
    }
    return null
  }

  async function closeModal() {
    const closeSelectors = [
      'button:has-text("Cancel")',
      'button:has-text("Close")',
      '[data-testid="close-modal"]',
      '.modal-close',
      '[aria-label="Close"]'
    ]
    
    await clickFirstAvailableButton(closeSelectors)
    await page.waitForTimeout(500)
  }
})